ğŸš€ LeetCode Solutions

ğŸ”¢ Problem 7: Reverse an Integer

ğŸ“Œ Problem Statement

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2Â³Â¹, 2Â³Â¹ - 1], then return 0.

ğŸ”— LeetCode Problem Link

ğŸ“ Example

âœ… Input:
```
x = 123
```
âœ… Output:
```
321
```
âœ… Input:
```
x = -123
```
âœ… Output:
```
-321
```
âœ… Input:
```
x = 120
```
âœ… Output:
```
21
```

ğŸ’¡ Approach

Initialize a variable ans of type long to store the reversed number.

Use a while loop to extract digits from x using modulo (% 10) and build ans by multiplying it by 10 and adding the extracted digit.

Continue this process until x becomes 0.

Check for overflow: If ans is out of the 32-bit integer range, return 0.

Otherwise, cast ans to int and return the result.

ğŸ’» Java Solution
```
class Solution {
    public int reverse(int x) {
        long ans=0;
        while (x!=0){
            ans= ans*10+x%10;
            x/=10;
        }
        return (ans<Integer.MIN_VALUE || ans>Integer.MAX_VALUE)? 0 :(int)ans;
    }
}
```
ğŸ“Š Complexity Analysis

â³ Time Complexity: O(logâ‚â‚€(n)), where n is the absolute value of x, since we process each digit.

ğŸ›  Space Complexity: O(1), as we use only a few extra variables.

ğŸ” Key Takeaways

âœ… Handles both positive and negative numbers correctly.âœ… Uses long to detect overflow before returning the result.âœ… Efficient and runs in logarithmic time.

ğŸ¯ Optimized for fast execution and memory efficiency! ğŸš€

